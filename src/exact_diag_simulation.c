#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <argp.h>
#include <time.h>
#include <math.h>
#include "constants.h"
#include "ham_gen/ham_gen.h"
#include "utils/utils.h"

//------------------------------------------------------------------------

/* Struct Declarations */
struct SystemParams {
    int len;
    int width;
    DTYPE coupling_const;
    DTYPE disorder_strength;
    DTYPE hop_strength;
    int (*neighbours)[NEIGHS];
    int numRuns; // Technically not a system parameter but it's convenient
    // to have it here.
    int nospin;
    int num_states;
};

struct OutStream {
    FILE * gfuncsq;
    FILE * dist_vs_gfuncsq;
};

//------------------------------------------------------------------------

/* Function Declarations */ 
int run(struct SystemParams * params, int create_neighbours,
            DTYPE * gfunc);
struct OutStream set_up_datastream(struct SystemParams params);
DTYPE post_process(struct SystemParams params, struct OutStream outfiles,
                DTYPE * gfunc);
static error_t parse_opt (int key, char *arg, struct argp_state *state);

//------------------------------------------------------------------------

/* Constant Declarations */
const char *argp_program_version =
  "exact_diag_simulation 1.0";
const char *argp_program_bug_address =
  "<aditya.chincholi@students.iiserpune.ac.in>";
// Program documentation.
static char doc[] =
  "exact_diag_simulation -- a simulation of spin-orbit coupled" 
  "2d many-body localized systems.";
// A description of the arguments we accept.
static char args_doc[] = "-s <size> -c <coupling_const>"
                        "-w <disorder_strength>"
                        " -t <hop_strength> -n <num_runs>";
// The options we understand.
static struct argp_option options[] = {
  {"size",     's', "SIZE",     0, "Length and width of the lattice",        0},
  {"coupling", 'c', "COUPLING", 0, "Spin-orbit coupling constant",           0},
  {"disorder", 'w', "DISORDER", 0, "Strength of the disorder",               0},
  {"hopping",  't', "HOPPING",  0, "Strength of the hopping",                0},
  {"runs",     'n', "NUMRUNS",  0, "Number of runs in the disorder average", 0},
  { 0 }
};
// Our argp parser.
static struct argp argp = { options, parse_opt, args_doc, doc, 0, 0, 0};

//------------------------------------------------------------------------

int main(int argc, char ** argv)
{
    struct SystemParams params;
    /* Default Values of Parameters */
    params.len = params.width = 20;
    params.coupling_const = 0;
    params.disorder_strength = 10;
    params.hop_strength = 1;
    params.numRuns = 100;
    params.nospin = 0;

    /* Parse our arguments; every option seen by parse_opt will
        be reflected in params. */
    argp_parse (&argp, argc, argv, 0, 0, &params);

    printf("len: %d coupling: %.2e\ndisorder: %.2e hopping: %.2e\n",
        params.len, params.coupling_const, params.disorder_strength,
        params.hop_strength);

    if(params.nospin)
        params.num_states = params.len*params.width;
    else
        params.num_states = 2*params.len*params.width;

    int ctr;
    struct OutStream outfiles = set_up_datastream(params);

    DTYPE avg_loc_len = 0;
    int create_neighbours = 1;

    // Seed all random numbers generated by the time 
    srandom((unsigned) time(NULL));



    // Allocate Green's Function Matrix
    // Represents long time limit of the green's function squared.
    DTYPE * gfunc = calloc(params.num_states*params.num_states, sizeof(DTYPE));

    /*
        run()
        -
        |    Create Hamiltonian
        |    Calculate Eigenvectors
        |    Calculate green's function
        |    Add to the existing gfunc matrix
        -
        post_process()
        -
        |    Divide the gfunc matrix to get disorder avged Green's function
        |    Output the disorder avged gfunc matrix
        |    Construct gfunc vs distance datapoints
        |    Fit exponential to the data
        |    Get localization length from exponent
        -
    */
    printf("Starting Simulation for Exact Diagonalization...\n");
    for(ctr = 1; ctr <= params.numRuns; ctr++)
    {
        printf("Run %d started...", ctr);
        fflush(stdout);
        /* Call run */
        run(&params, create_neighbours, gfunc);
        create_neighbours = 0;
        
        printf("\tDone\n");
    }

    avg_loc_len = post_process(params, outfiles, gfunc);
    printf("Disorder Averaged Loc Len: %e\n", avg_loc_len);

    fclose(outfiles.gfuncsq);
    free(params.neighbours);
    free(gfunc);
    return(0);
}

struct OutStream set_up_datastream(struct SystemParams params)
{
    struct OutStream outfiles;
    char base[16];
    char basename[64];
    char gfuncname[80];
    char dvsgfname[80];

    if (params.nospin)
      strcpy(base, "data/mbl_nospin");
    else
      strcpy(base, "data/mbl");

    sprintf(basename, "%s_%dx%d_W%.4g_C%.4g_T%.4g_", base, params.len,
            params.width, params.disorder_strength, params.coupling_const,
            params.hop_strength);
    sprintf(gfuncname, "%sgreenfuncsq.dat", basename);
    sprintf(dvsgfname, "%sdistvsgfsq.dat", basename);

    outfiles.gfuncsq = fopen(gfuncname, "w");
    outfiles.dist_vs_gfuncsq = fopen(dvsgfname, "w");
    
    if (outfiles.gfuncsq == NULL)
    {
        printf("Failed to open %s", gfuncname);
        exit(1);
    }
    if (outfiles.dist_vs_gfuncsq == NULL)
    {
        printf("Failed to open %s", dvsgfname);
        exit(1);
    }

    return(outfiles);
}

/*
    Creates a hamiltonian based on params, calculates the
    long time green's function squared and ADDS it to gfunc.
    Please ensure gfunc is initialized properly for your
    purpose.
*/
int run(struct SystemParams * params, int create_neighbours,
            DTYPE * gfunc)
{
    int num_sites = params->len * params->width;
    int num_states = params->num_states;

    // Create neighbour list if not present
    if (create_neighbours)
    {
        params->neighbours = malloc((num_sites*NEIGHS)*sizeof(int)); 
        get_neighbour_lists(params->neighbours, params->len, params->width);
    }

    // Create hamiltonian
    CDTYPE * ham = calloc(num_states*num_states,sizeof(CDTYPE));
    
    if(params->nospin)
        hamiltonian_nospin(ham, params->len, params->width,
                params->disorder_strength, params->hop_strength,
                params->neighbours);
    else
        hamiltonian(ham, params->len, params->width, params->coupling_const,
                params->disorder_strength, params->hop_strength,
                params->neighbours);

    // Calculate eigenvectors
    DTYPE * eigvals = calloc(num_states, sizeof(DTYPE));
    utils_get_eigh(ham, num_states, eigvals);

    // Calculate and add green's function long time limit squared
    utils_get_green_func_lim(ham, num_states, gfunc);

    free(eigvals);
    free(ham);

    return(0);
}

/*

*/
DTYPE post_process(struct SystemParams params, struct OutStream outfiles,
                DTYPE * gfunc)
{
    int i, j;
    int num_states = params.num_states;
    // Divide the gfunc matrix to get disorder avged Green's function
    for(i = 0; i < (num_states*num_states); i++)
    {
        *(gfunc + i) /= (DTYPE) params.numRuns;
        if(isnan(*(gfunc + i)))
        {
            printf("We have a problem!!\n");
            printf("NaN detected at i=%d in gfunc", i);
        }
    }

    // Output the disorder avged gfunc matrix
    for(i = 0; i < num_states; i++)
    {
        for(j = 0; j < num_states; j++)
        {
            fprintf(outfiles.gfuncsq ,"%e ", *(gfunc + RTC(i,j,num_states)));
        }
        fprintf(outfiles.gfuncsq, "\n");
    }

    // Construct gfunc vs distance datapoints
    DTYPE * dists;
    DTYPE * gfuncsq_vals;
    int data_len;
    DTYPE exponent, mantissa, residuals;
    // exponent = mantissa = residuals = 0;
    data_len = utils_construct_data_vs_dist(gfunc, num_states, params.len,
                                        &dists, &gfuncsq_vals);


    // Write the values to a file
    for(i = 0; i < data_len; i++)
    {
        fprintf(outfiles.dist_vs_gfuncsq, "%e %e\n",
                *(dists + i), *(gfuncsq_vals + i));
    }

    // Fit exponential to the data
    utils_fit_exponential(dists, gfuncsq_vals, data_len,
                        &exponent, &mantissa, &residuals);
    
    printf("Residuals: %e\n", residuals);
    // Get localization length from exponent
    DTYPE loclen = -2 / exponent;

    free(dists);
    free(gfuncsq_vals);
    return(loclen);
}

/* Parse a single option. */
static error_t parse_opt (int key, char *arg, struct argp_state *state)
{
    /* Get the input argument from argp_parse, which we
     know is a pointer to our arguments structure. */
    struct SystemParams *params = state->input;

    switch (key)
        {
        case 's':
            params->len = params->width = atoi(arg);
            break;
        case 'c':
            params->coupling_const = atof(arg);
            break;
        case 'w':
            params->disorder_strength = atof(arg);
            break;
        case 't':
            params->hop_strength = atof(arg);
            break;
        case 'n':
            params->numRuns = atoi(arg);
            break;

        default:
            return ARGP_ERR_UNKNOWN;
        }
    return 0;
}



